% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reactiveNavigation.R
\name{reactiveNavigation}
\alias{reactiveNavigation}
\alias{updateNavigation}
\alias{outputNavigation}
\alias{getNavigation}
\alias{observeModuleNavigation}
\title{Reactive navigation}
\usage{
reactiveNavigation(value = NULL)

updateNavigation(state, value, force_react = TRUE)

outputNavigation(state, force_react = TRUE)

getNavigation(module)

observeModuleNavigation(state, modules, force_react = TRUE,
  logger = NULL)
}
\arguments{
\item{value}{}
}
\value{
TBD
}
\description{
Set of utilities providing a common way to store reactive navigation state
and propagate it as or retrieve it from module outputs, supporting navigation
across nested modules.
}
\details{
The details behind how the navigation state is stored, propagated and
observed are encapsulate using utilities for initializing the state
(\code{reactiveNavigation()}), updating it (\code{updateNavigation()}), making it a
module output reactive list element (\code{outputNavigation()}), retrieving it from
a module output (\code{getNavigation()}). Observing and collecting navigation
state from a list of (sub-) modules (\code{observeModuleNavigation()}) allows
flexible modular configurations with arbitrarily nested modules.

This functionality provides a common, aligned way of handling navigation,
abstracting from the specific implementation details. In fact, from the user
(shiny app developer) perspective, there is no need to explicitly know how
the navigation state is internally stored or called.

Enabling navigation in the sever or a module's server function) boils down
to:\preformatted{# [...]
# initialize the reactive navigation state
navigation_state <- reactiveNavigation()
# [...]
# possibly observe what is relevant for the update of the navigation state
observeEvent(..., {updateNavigation(navigation_state, new_value)})
# possibly observe the navigation coming from a list of (sub)modules outout
observeModuleNavigation(navigation_state, modules)
# [...]
# construct the navigation-related part of the module output list
result <- c(
  outputNavigation(navigation_state),
  list(other_reactive_outputs)
)
[...]
# get the reactive value when needed (typically in the top-level module/server)
getNavigation(navigation_state)
getNavigation(outputNavigation(navigation_state))
[...]
}
}
\examples{

}
